; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -O2 -mtriple=m68k-linux-gnu -verify-machineinstrs \
; RUN:              -code-model=small -relocation-model=static \
; RUN:   | FileCheck %s

; RUN: llc < %s -O2 -mtriple=m68k-linux-gnu -verify-machineinstrs \
; RUN:              -code-model=small -relocation-model=static -mattr="+use-pcrel" \
; RUN:   | FileCheck %s --check-prefix=CHECK-PCREL

; RUN: llc < %s -O2 -mtriple=m68k-linux-gnu -verify-machineinstrs \
; RUN:              -code-model=small -relocation-model=pic \
; RUN:   | FileCheck %s --check-prefix=CHECK-PIC

@ptr = external global i32*
@dst = external global i32
@src = external global i32

define void @test0() nounwind {
; CHECK-LABEL: test0:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    move.l #dst, ptr
; CHECK-NEXT:    move.l src, dst
; CHECK-NEXT:    rts
;
; CHECK-PCREL-LABEL: test0:
; CHECK-PCREL:       ; %bb.0: ; %entry
; CHECK-PCREL-NEXT:    lea (dst,%pc), %a0
; CHECK-PCREL-NEXT:    move.l %a0, (ptr,%pc)
; CHECK-PCREL-NEXT:    move.l (src,%pc), (dst,%pc)
; CHECK-PCREL-NEXT:    rts
;
; CHECK-PIC-LABEL: test0:
; CHECK-PIC:       ; %bb.0: ; %entry
; CHECK-PIC-NEXT:    move.l (dst@GOTPCREL,%pc), %a0
; CHECK-PIC-NEXT:    move.l (ptr@GOTPCREL,%pc), %a1
; CHECK-PIC-NEXT:    move.l %a0, (%a1)
; CHECK-PIC-NEXT:    move.l (src@GOTPCREL,%pc), %a1
; CHECK-PIC-NEXT:    move.l (%a1), (%a0)
; CHECK-PIC-NEXT:    rts
entry:
    store i32* @dst, i32** @ptr
    %tmp.s = load i32, i32* @src
    store i32 %tmp.s, i32* @dst
    ret void
}

@ptr2 = global i32* null
@dst2 = global i32 0
@src2 = global i32 0

define void @test1() nounwind {
; CHECK-LABEL: test1:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    move.l #dst2, ptr2
; CHECK-NEXT:    move.l src2, dst2
; CHECK-NEXT:    rts
;
; CHECK-PCREL-LABEL: test1:
; CHECK-PCREL:       ; %bb.0: ; %entry
; CHECK-PCREL-NEXT:    lea (dst2,%pc), %a0
; CHECK-PCREL-NEXT:    move.l %a0, (ptr2,%pc)
; CHECK-PCREL-NEXT:    move.l (src2,%pc), (dst2,%pc)
; CHECK-PCREL-NEXT:    rts
;
; CHECK-PIC-LABEL: test1:
; CHECK-PIC:       ; %bb.0: ; %entry
; CHECK-PIC-NEXT:    move.l (dst2@GOTPCREL,%pc), %a0
; CHECK-PIC-NEXT:    move.l (ptr2@GOTPCREL,%pc), %a1
; CHECK-PIC-NEXT:    move.l %a0, (%a1)
; CHECK-PIC-NEXT:    move.l (src2@GOTPCREL,%pc), %a1
; CHECK-PIC-NEXT:    move.l (%a1), (%a0)
; CHECK-PIC-NEXT:    rts
entry:
    store i32* @dst2, i32** @ptr2
    %tmp.s = load i32, i32* @src2
    store i32 %tmp.s, i32* @dst2
    ret void
}

declare i8* @malloc(i32)

define void @test2() nounwind {
; CHECK-LABEL: test2:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    suba.l #4, %sp
; CHECK-NEXT:    move.l #40, (%sp)
; CHECK-NEXT:    jsr malloc@PLT
; CHECK-NEXT:    adda.l #4, %sp
; CHECK-NEXT:    rts
;
; CHECK-PCREL-LABEL: test2:
; CHECK-PCREL:       ; %bb.0: ; %entry
; CHECK-PCREL-NEXT:    suba.l #4, %sp
; CHECK-PCREL-NEXT:    move.l #40, (%sp)
; CHECK-PCREL-NEXT:    jsr malloc@PLT
; CHECK-PCREL-NEXT:    adda.l #4, %sp
; CHECK-PCREL-NEXT:    rts
;
; CHECK-PIC-LABEL: test2:
; CHECK-PIC:       ; %bb.0: ; %entry
; CHECK-PIC-NEXT:    suba.l #4, %sp
; CHECK-PIC-NEXT:    move.l #40, (%sp)
; CHECK-PIC-NEXT:    jsr (malloc@PLT,%pc)
; CHECK-PIC-NEXT:    adda.l #4, %sp
; CHECK-PIC-NEXT:    rts
entry:
    %ptr = call i8* @malloc(i32 40)
    ret void
}

@pfoo = external global void(...)*
declare void(...)* @afoo(...)

define void @test3() nounwind {
; CHECK-LABEL: test3:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    suba.l #4, %sp
; CHECK-NEXT:    jsr afoo@PLT
; CHECK-NEXT:    move.l %a0, pfoo
; CHECK-NEXT:    jsr (%a0)
; CHECK-NEXT:    adda.l #4, %sp
; CHECK-NEXT:    rts
;
; CHECK-PCREL-LABEL: test3:
; CHECK-PCREL:       ; %bb.0: ; %entry
; CHECK-PCREL-NEXT:    suba.l #4, %sp
; CHECK-PCREL-NEXT:    jsr afoo@PLT
; CHECK-PCREL-NEXT:    move.l %a0, (pfoo,%pc)
; CHECK-PCREL-NEXT:    jsr (%a0)
; CHECK-PCREL-NEXT:    adda.l #4, %sp
; CHECK-PCREL-NEXT:    rts
;
; CHECK-PIC-LABEL: test3:
; CHECK-PIC:       ; %bb.0: ; %entry
; CHECK-PIC-NEXT:    suba.l #4, %sp
; CHECK-PIC-NEXT:    jsr (afoo@PLT,%pc)
; CHECK-PIC-NEXT:    move.l (pfoo@GOTPCREL,%pc), %a1
; CHECK-PIC-NEXT:    move.l %a0, (%a1)
; CHECK-PIC-NEXT:    jsr (%a0)
; CHECK-PIC-NEXT:    adda.l #4, %sp
; CHECK-PIC-NEXT:    rts
entry:
    %tmp = call void(...)*(...) @afoo()
    store void(...)* %tmp, void(...)** @pfoo
    %tmp1 = load void(...)*, void(...)** @pfoo
    call void(...) %tmp1()
    ret void
}

declare void @foo(...)

define void @test4() nounwind {
; CHECK-LABEL: test4:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    suba.l #4, %sp
; CHECK-NEXT:    jsr foo@PLT
; CHECK-NEXT:    adda.l #4, %sp
; CHECK-NEXT:    rts
;
; CHECK-PCREL-LABEL: test4:
; CHECK-PCREL:       ; %bb.0: ; %entry
; CHECK-PCREL-NEXT:    suba.l #4, %sp
; CHECK-PCREL-NEXT:    jsr foo@PLT
; CHECK-PCREL-NEXT:    adda.l #4, %sp
; CHECK-PCREL-NEXT:    rts
;
; CHECK-PIC-LABEL: test4:
; CHECK-PIC:       ; %bb.0: ; %entry
; CHECK-PIC-NEXT:    suba.l #4, %sp
; CHECK-PIC-NEXT:    jsr (foo@PLT,%pc)
; CHECK-PIC-NEXT:    adda.l #4, %sp
; CHECK-PIC-NEXT:    rts
entry:
    call void(...) @foo()
    ret void
}

@ptr6 = internal global i32* null
@dst6 = internal global i32 0
@src6 = internal global i32 0

define void @test5() nounwind {
; CHECK-LABEL: test5:
; CHECK:       ; %bb.0: ; %entry
; CHECK-NEXT:    move.l #dst6, ptr6
; CHECK-NEXT:    move.l src6, dst6
; CHECK-NEXT:    rts
;
; CHECK-PCREL-LABEL: test5:
; CHECK-PCREL:       ; %bb.0: ; %entry
; CHECK-PCREL-NEXT:    lea (dst6,%pc), %a0
; CHECK-PCREL-NEXT:    move.l %a0, (ptr6,%pc)
; CHECK-PCREL-NEXT:    move.l (src6,%pc), (dst6,%pc)
; CHECK-PCREL-NEXT:    rts
;
; CHECK-PIC-LABEL: test5:
; CHECK-PIC:       ; %bb.0: ; %entry
; CHECK-PIC-NEXT:    move.l (dst6@GOTPCREL,%pc), %a0
; CHECK-PIC-NEXT:    move.l (ptr6@GOTPCREL,%pc), %a1
; CHECK-PIC-NEXT:    move.l %a0, (%a1)
; CHECK-PIC-NEXT:    move.l (src6@GOTPCREL,%pc), %a1
; CHECK-PIC-NEXT:    move.l (%a1), (%a0)
; CHECK-PIC-NEXT:    rts
entry:
    store i32* @dst6, i32** @ptr6
    %tmp.s = load i32, i32* @src6
    store i32 %tmp.s, i32* @dst6
    ret void
}

